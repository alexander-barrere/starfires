endpoint: OPENAI
model: gpt-4-1106-preview
messages:
- role: system
  content: You are a full stack software developer who works in a software development agency. You write very modular and
    clean code. Your job is to implement tasks that your tech lead assigns you. Each task has a description of what needs
    to be implemented, a programmatic goal that will determine if a task can be marked as done and user-review goal that will
    determine if a task is done or not but from a user perspective since it will be reviewed by a human.
- role: user
  content: "Here is how the file `controllers/userController.js` looks like right now:\n```\nconst bcrypt = require('bcryptjs');\n\
    const jwt = require('jsonwebtoken');\nconst { validationResult } = require('express-validator');\nconst User = require('../models/User');\n\
    \nexports.register = async (req, res) => {\n  const errors = validationResult(req);\n  if (!errors.isEmpty()) {\n    return\
    \ res.status(400).json({ errors: errors.array() });\n  }\n  \n  let { username, email, password, birthDate, birthTime,\
    \ birthLatitude, birthLongitude } = req.body;\n  \n  try {\n    let user = await User.findOne({ email });\n    if (user)\
    \ {\n      return res.status(400).json({ errors: [{ msg: 'User already exists' }] });\n    }\n\n    user = new User({\n\
    \      username,\n      email,\n      password,\n      birthDate,\n      birthTime,\n      birthLatitude,\n      birthLongitude\n\
    \    });\n\n    const salt = await bcrypt.genSalt(10);\n    user.password = await bcrypt.hash(password, salt);\n\n   \
    \ await user.save();\n\n    const payload = {\n      user: {\n        id: user.id\n      }\n    };\n\n    jwt.sign(\n\
    \      payload,\n      process.env.JWT_SECRET,\n      { expiresIn: 3600 },\n      (err, token) => {\n        if(err) throw\
    \ err;\n        res.json({ token });\n      }\n    );\n  } catch (err) {\n    console.error(err.message);\n    res.status(500).send('Server\
    \ error');\n  }\n};\n\nexports.login = async (req, res) => {\n  const errors = validationResult(req);\n  if (!errors.isEmpty())\
    \ {\n    return res.status(400).json({ errors: errors.array() });\n  }\n\n  const { email, password } = req.body;\n\n\
    \  try {\n    let user = await User.findOne({ email });\n    if (!user) {\n      return res.status(400).json({ errors:\
    \ [{ msg: 'Invalid Credentials' }] });\n    }\n\n    const isMatch = await bcrypt.compare(password, user.password);\n\
    \    if (!isMatch) {\n      return res.status(400).json({ errors: [{ msg: 'Invalid Credentials' }] });\n    }\n\n    const\
    \ payload = {\n      user: {\n        id: user.id\n      }\n    };\n\n    jwt.sign(\n      payload,\n      process.env.JWT_SECRET,\n\
    \      { expiresIn: 3600 },\n      (err, token) => {\n        if(err) throw err;\n        res.json({ token });\n     \
    \ }\n    );\n  } catch(err) {\n    console.error(err.message);\n    res.status(500).send('Server error');\n  }\n};\n\n\
    exports.adminLogin = async (req, res) => {\n  const { email, password } = req.body;\n\n  try {\n    let user = await User.findOne({\
    \ email });\n    if (!user || user.role !== 'admin') {\n      return res.status(401).json({ errors: [{ msg: 'Unauthorized'\
    \ }] });\n    }\n\n    const isMatch = await bcrypt.compare(password, user.password);\n    if (!isMatch) {\n      return\
    \ res.status(401).json({ errors: [{ msg: 'Unauthorized' }] });\n    }\n\n    const payload = {\n      user: {\n      \
    \  id: user.id\n      }\n    };\n\n    jwt.sign(\n      payload,\n      process.env.JWT_SECRET,\n      { expiresIn: '1h'\
    \ },\n      (err, token) => {\n        if (err) throw err;\n        res.json({ token });\n      }\n    );\n  } catch (err)\
    \ {\n    console.error(err.message);\n    res.status(500).send('Server error');\n  }\n};\n\n```\n\nAnd here is the new\
    \ implementation for the same file:\n```\n// All previous imports\nexports.register = async (req, res) => {\n  const errors\
    \ = validationResult(req);\n  if (!errors.isEmpty()) {\n    return res.status(400).json({ errors: errors.array() });\n\
    \  }\n  \n  const { username, email, password, birthDate, birthTime, birthLatitude, birthLongitude } = req.body;\n  \n\
    \  try {\n    let user = await User.findOne({ email });\n    if (user) {\n      return res.status(400).json({ errors:\
    \ [{ msg: 'User already exists' }] });\n    }\n\n    const birthDateObject = birthDate ? new Date(birthDate) : null;\n\
    \n    user = new User({\n      username,\n      email,\n      password,\n      birthDate: birthDateObject,\n      birthTime,\n\
    \      birthLatitude: parseFloat(birthLatitude),\n      birthLongitude: parseFloat(birthLongitude)\n    });\n\n    const\
    \ salt = await bcrypt.genSalt(10);\n    user.password = await bcrypt.hash(password, salt);\n\n    await user.save();\n\
    \n    const payload = {\n      user: {\n        id: user.id\n      }\n    };\n\n    jwt.sign(\n      payload,\n      process.env.JWT_SECRET,\n\
    \      { expiresIn: 3600 },\n      (err, token) => {\n        if(err) throw err;\n        res.json({ token });\n     \
    \ }\n    );\n  } catch (err) {\n    console.error(err.message);\n    res.status(500).send('Server error');\n  }\n};\n\
    // [OLD CODE] Add the rest of the file content here\n\n```\n\nNow, implement the new changes into the previously implemented\
    \ file and return the entirely coded file. Do not add any lines of code that are not in the previously coded file or the\
    \ new implementation but only combine those two.\n\n**IMPORTANT**\nAll lines of code in the new implementation should\
    \ be present. From the old implementation, only take the ones that are replaced with the comment `[OLD CODE]` in the new\
    \ implementation\n\n**IMPORTANT**\nMake sure that you respond with all lines of code that are replaced by these comments,\
    \ including all control structures, error handling, and any other relevant logic that was in the original code.\nUnder\
    \ no circumstances should you ever leave any part of the code snippet unwritten. Every single line of code that exists\
    \ in the place where the comment lives right now should be replaced. Do not include any code that is above or below the\
    \ comment but only the code that should be in the position of the comment."
- role: user
  content: "**IMPORTANT**\nYou must respond with ONLY the JSON object, with NO additional text or explanation.\n\nHere is\
    \ the schema for the expected JSON object:\n```json\n{\n    \"file_content\": {\n        \"type\": \"string\",\n     \
    \   \"description\": \"Fully coded file. This contains only the lines of code and no other text.\"\n    }\n}\n```\n\n"
response: "```json\n{\n    \"file_content\": \"const bcrypt = require('bcryptjs');\\nconst jwt = require('jsonwebtoken');\\\
  nconst { validationResult } = require('express-validator');\\nconst User = require('../models/User');\\n\\nexports.register\
  \ = async (req, res) => {\\n  const errors = validationResult(req);\\n  if (!errors.isEmpty()) {\\n    return res.status(400).json({\
  \ errors: errors.array() });\\n  }\\n  \\n  const { username, email, password, birthDate, birthTime, birthLatitude, birthLongitude\
  \ } = req.body;\\n  \\n  try {\\n    let user = await User.findOne({ email });\\n    if (user) {\\n      return res.status(400).json({\
  \ errors: [{ msg: 'User already exists' }] });\\n    }\\n\\n    const birthDateObject = birthDate ? new Date(birthDate)\
  \ : null;\\n\\n    user = new User({\\n      username,\\n      email,\\n      password,\\n      birthDate: birthDateObject,\\\
  n      birthTime,\\n      birthLatitude: parseFloat(birthLatitude),\\n      birthLongitude: parseFloat(birthLongitude)\\\
  n    });\\n\\n    const salt = await bcrypt.genSalt(10);\\n    user.password = await bcrypt.hash(password, salt);\\n\\n\
  \    await user.save();\\n\\n    const payload = {\\n      user: {\\n        id: user.id\\n      }\\n    };\\n\\n    jwt.sign(\\\
  n      payload,\\n      process.env.JWT_SECRET,\\n      { expiresIn: 3600 },\\n      (err, token) => {\\n        if(err)\
  \ throw err;\\n        res.json({ token });\\n      }\\n    );\\n  } catch (err) {\\n    console.error(err.message);\\n\
  \    res.status(500).send('Server error');\\n  }\\n};\\n\\nexports.login = async (req, res) => {\\n  const errors = validationResult(req);\\\
  n  if (!errors.isEmpty()) {\\n    return res.status(400).json({ errors: errors.array() });\\n  }\\n\\n  const { email, password\
  \ } = req.body;\\n\\n  try {\\n    let user = await User.findOne({ email });\\n    if (!user) {\\n      return res.status(400).json({\
  \ errors: [{ msg: 'Invalid Credentials' }] });\\n    }\\n\\n    const isMatch = await bcrypt.compare(password, user.password);\\\
  n    if (!isMatch) {\\n      return res.status(400).json({ errors: [{ msg: 'Invalid Credentials' }] });\\n    }\\n\\n  \
  \  const payload = {\\n      user: {\\n        id: user.id\\n      }\\n    };\\n\\n    jwt.sign(\\n      payload,\\n   \
  \   process.env.JWT_SECRET,\\n      { expiresIn: 3600 },\\n      (err, token) => {\\n        if(err) throw err;\\n     \
  \   res.json({ token });\\n      }\\n    );\\n  } catch(err) {\\n    console.error(err.message);\\n    res.status(500).send('Server\
  \ error');\\n  }\\n};\\n\\nexports.adminLogin = async (req, res) => {\\n  const { email, password } = req.body;\\n\\n  try\
  \ {\\n    let user = await User.findOne({ email });\\n    if (!user || user.role !== 'admin') {\\n      return res.status(401).json({\
  \ errors: [{ msg: 'Unauthorized' }] });\\n    }\\n\\n    const isMatch = await bcrypt.compare(password, user.password);\\\
  n    if (!isMatch) {\\n      return res.status(401).json({ errors: [{ msg: 'Unauthorized' }] });\\n    }\\n\\n    const\
  \ payload = {\\n      user: {\\n        id: user.id\\n      }\\n    };\\n\\n    jwt.sign(\\n      payload,\\n      process.env.JWT_SECRET,\\\
  n      { expiresIn: '1h' },\\n      (err, token) => {\\n        if (err) throw err;\\n        res.json({ token });\\n  \
  \    }\\n    );\\n  } catch (err) {\\n    console.error(err.message);\\n    res.status(500).send('Server error');\\n  }\\\
  n};\\n\"\n}\n```"
